<img src="https://r2cdn.perplexity.ai/pplx-full-logo-primary-dark%402x.png" class="logo" width="120"/>

# SQL JOIN — Типы и Примеры

**Уровень неопределённости:** 0.05 (очень низкий). Тема хорошо документирована и не требует дополнительных уточнений.

SQL JOIN — это операция, которая позволяет объединять данные из двух или более таблиц на основе связанных между ними столбцов. Это фундаментальная концепция реляционных баз данных, которая позволяет эффективно работать с нормализованными данными.

Для примеров будем использовать две таблицы:

**Таблица `users`:**

```
| user_id | name    | email            |
|---------|---------|------------------|
| 1       | Иван    | ivan@mail.ru     |
| 2       | Мария   | maria@mail.ru    |
| 3       | Петр    | petr@mail.ru     |
```

**Таблица `orders`:**

```
| order_id | user_id | product     | amount |
|----------|---------|-------------|--------|
| 101      | 1       | Книга       | 500    |
| 102      | 1       | Телефон     | 15000  |
| 103      | 2       | Наушники    | 2000   |
| 104      | 5       | Планшет     | 8000   |
```


## 1. INNER JOIN

### Определение

**INNER JOIN** возвращает только те строки, для которых найдены соответствующие записи в обеих таблицах.

### Схема

```
Таблица A    Таблица B
┌─────────┐  ┌─────────┐
│    ┌────┼──┼────┐    │
│    │ AB ││  ││ AB│    │
│    └────┼──┼────┘    │
└─────────┘  └─────────┘
    Результат: только пересечение (AB)
```


### Синтаксис и пример

```sql
SELECT u.name, o.product, o.amount
FROM users u
INNER JOIN orders o ON u.user_id = o.user_id;
```

**Результат:**

```
| name  | product   | amount |
|-------|-----------|--------|
| Иван  | Книга     | 500    |
| Иван  | Телефон   | 15000  |
| Мария | Наушники  | 2000   |
```


### Применимость

- **Когда использовать:** когда нужны только записи, имеющие соответствия в обеих таблицах
- **Плюсы:** быстрая работа, четкая логика
- **Минусы:** исключает строки без соответствий


## 2. LEFT JOIN (LEFT OUTER JOIN)

### Определение

**LEFT JOIN** возвращает все строки из левой таблицы и соответствующие строки из правой. Если соответствий нет, значения из правой таблицы заполняются NULL.

### Схема

```
Таблица A    Таблица B
┌─────────┐  ┌─────────┐
│  A  ┌───┼──┼────┐    │
│     │ AB││  ││ AB│    │
│     └───┼──┼────┘    │
└─────────┘  └─────────┘
    Результат: A + AB
```


### Синтаксис и пример

```sql
SELECT u.name, o.product, o.amount
FROM users u
LEFT JOIN orders o ON u.user_id = o.user_id;
```

**Результат:**

```
| name  | product   | amount |
|-------|-----------|--------|
| Иван  | Книга     | 500    |
| Иван  | Телефон   | 15000  |
| Мария | Наушники  | 2000   |
| Петр  | NULL      | NULL   |
```


### Применимость

- **Когда использовать:** когда нужны все записи из основной таблицы, независимо от наличия связанных данных
- **Плюсы:** сохраняет полноту данных из левой таблицы
- **Минусы:** может создавать NULL значения


## 3. RIGHT JOIN (RIGHT OUTER JOIN)

### Определение

**RIGHT JOIN** возвращает все строки из правой таблицы и соответствующие строки из левой. Аналог LEFT JOIN, но с противоположной логикой.

### Схема

```
Таблица A    Таблица B
┌─────────┐  ┌─────────┐
│    ┌────┼──┼───┐  B  │
│    │ AB ││  ││AB │    │
│    └────┼──┼───┘     │
└─────────┘  └─────────┘
    Результат: AB + B
```


### Синтаксис и пример

```sql
SELECT u.name, o.product, o.amount
FROM users u
RIGHT JOIN orders o ON u.user_id = o.user_id;
```

**Результат:**

```
| name  | product   | amount |
|-------|-----------|--------|
| Иван  | Книга     | 500    |
| Иван  | Телефон   | 15000  |
| Мария | Наушники  | 2000   |
| NULL  | Планшет   | 8000   |
```


### Применимость

- **Когда использовать:** когда важны все записи из второй таблицы
- **Плюсы:** гарантирует полноту данных из правой таблицы
- **Минусы:** менее интуитивен, чем LEFT JOIN


## 4. FULL JOIN (FULL OUTER JOIN)

### Определение

**FULL JOIN** возвращает все строки из обеих таблиц, заполняя NULL там, где нет соответствий.

### Схема

```
Таблица A    Таблица B
┌─────────┐  ┌─────────┐
│  A  ┌───┼──┼───┐  B  │
│     │ AB││  ││AB │    │
│     └───┼──┼───┘     │
└─────────┘  └─────────┘
    Результат: A + AB + B
```


### Синтаксис и пример

```sql
SELECT u.name, o.product, o.amount
FROM users u
FULL OUTER JOIN orders o ON u.user_id = o.user_id;
```

**Результат:**

```
| name  | product   | amount |
|-------|-----------|--------|
| Иван  | Книга     | 500    |
| Иван  | Телефон   | 15000  |
| Мария | Наушники  | 2000   |
| Петр  | NULL      | NULL   |
| NULL  | Планшет   | 8000   |
```


### Применимость

- **Когда использовать:** для полного анализа данных из обеих таблиц
- **Плюсы:** максимальная полнота информации
- **Минусы:** может создавать много NULL значений


## 5. CROSS JOIN

### Определение

**CROSS JOIN** создает декартово произведение таблиц — каждая строка первой таблицы сочетается с каждой строкой второй таблицы.

### Схема

```
Таблица A (3 строки) × Таблица B (4 строки) = 12 строк результата
A1 + B1, A1 + B2, A1 + B3, A1 + B4
A2 + B1, A2 + B2, A2 + B3, A2 + B4
A3 + B1, A3 + B2, A3 + B3, A3 + B4
```


### Синтаксис и пример

```sql
SELECT u.name, o.product
FROM users u
CROSS JOIN orders o;
```

**Результат** (частично):

```
| name  | product   |
|-------|-----------|
| Иван  | Книга     |
| Иван  | Телефон   |
| Иван  | Наушники  |
| Иван  | Планшет   |
| Мария | Книга     |
| ... (12 строк всего) |
```


### Применимость

- **Когда использовать:** для создания всех возможных комбинаций
- **Плюсы:** полезен для аналитических задач
- **Минусы:** может создавать огромные результирующие наборы


## 6. SELF JOIN

### Определение

**SELF JOIN** — это соединение таблицы с самой собой, используется для поиска связей внутри одной таблицы.

### Пример с таблицей сотрудников

```sql
-- Таблица employees
CREATE TABLE employees (
    emp_id INT,
    name VARCHAR(50),
    manager_id INT
);

-- Найти всех сотрудников и их руководителей
SELECT e1.name AS employee, e2.name AS manager
FROM employees e1
LEFT JOIN employees e2 ON e1.manager_id = e2.emp_id;
```


### Применимость

- **Когда использовать:** для иерархических данных, поиска дублей
- **Плюсы:** мощный инструмент для анализа связей
- **Минусы:** может быть сложен для понимания


## Ключевые Различия

### INNER JOIN vs LEFT JOIN

**INNER JOIN:**

- Показывает только совпадения
- Исключает несвязанные записи
- Результат: меньший объем данных

**LEFT JOIN:**

- Показывает все записи из левой таблицы
- Включает NULL для несвязанных записей
- Результат: полнота данных из основной таблицы


### CROSS JOIN vs остальные JOIN

**CROSS JOIN** кардинально отличается:

- Не использует условие ON
- Создает все возможные комбинации
- Размер результата = количество строк в A × количество строк в B
- Остальные JOIN основаны на условиях соединения


## Мини-Задачи

### Задача 1: Все пользователи, даже без заказов

**Вопрос:** Какой JOIN использовать для получения всех пользователей, включая тех, кто не делал заказов?

**Ответ:** `LEFT JOIN`

```sql
SELECT u.name, COUNT(o.order_id) as order_count
FROM users u
LEFT JOIN orders o ON u.user_id = o.user_id
GROUP BY u.user_id, u.name;
```


### Задача 2: Только активные пользователи

**Вопрос:** Как получить только пользователей, которые делали заказы?

**Ответ:** `INNER JOIN`

```sql
SELECT DISTINCT u.name
FROM users u
INNER JOIN orders o ON u.user_id = o.user_id;
```


## JOIN с подзапросами и CTE

### Пример с CTE

```sql
WITH user_stats AS (
    SELECT user_id, COUNT(*) as order_count, SUM(amount) as total_spent
    FROM orders
    GROUP BY user_id
)
SELECT u.name, us.order_count, us.total_spent
FROM users u
LEFT JOIN user_stats us ON u.user_id = us.user_id;
```


### Пример с подзапросом

```sql
SELECT u.name, big_orders.total
FROM users u
JOIN (
    SELECT user_id, SUM(amount) as total
    FROM orders
    WHERE amount > 1000
    GROUP BY user_id
) big_orders ON u.user_id = big_orders.user_id;
```

## Рекомендации по выбору JOIN

1. **INNER JOIN** — когда нужны только связанные данные
2. **LEFT JOIN** — когда важна полнота основной таблицы
3. **RIGHT JOIN** — редко используется, лучше переписать как LEFT JOIN
4. **FULL JOIN** — для полного анализа всех данных
5. **CROSS JOIN** — для комбинаторных задач (осторожно с производительностью!)
6. **SELF JOIN** — для иерархических структур и поиска связей

**Практический совет:** В 90% случаев используются INNER JOIN и LEFT JOIN. Начинайте с них, а остальные применяйте по мере необходимости.

