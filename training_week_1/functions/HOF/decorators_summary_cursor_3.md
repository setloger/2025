# Резюме: Декораторы с параметрами и сохранение свойств функций

## Ключевые концепции

### 1. Декораторы с параметрами
Декораторы с параметрами - это "фабрики декораторов", которые принимают параметры и возвращают декоратор.

**Структура:**
```python
def decorator_with_params(param1, param2, ...):
    def decorator(func):
        @functools.wraps(func)
        def wrapper(*args, **kwargs):
            # Логика с использованием параметров
            return func(*args, **kwargs)
        return wrapper
    return decorator
```

### 2. Сохранение метаданных
`functools.wraps` сохраняет важные свойства декорируемой функции:
- `__name__` - имя функции
- `__doc__` - документация
- `__module__` - модуль
- `__annotations__` - аннотации типов
- `__qualname__` - квалифицированное имя

## Практические примеры

### Базовые декораторы
1. **repeat(times)** - повторяет выполнение функции
2. **retry(max_attempts, delay)** - повторные попытки при ошибках
3. **validate_input(validator, error_message)** - валидация входных данных
4. **cache_with_ttl(ttl_seconds)** - кэширование с временем жизни

### Продвинутые декораторы
1. **log_function_call(logger)** - логирование вызовов
2. **measure_time(description)** - измерение времени выполнения
3. **timeout(seconds)** - ограничение времени выполнения
4. **rate_limit(calls, period)** - ограничение частоты вызовов

## Лучшие практики

### ✅ Правильно
```python
import functools

def good_decorator(param1, param2="default"):
    def decorator(func):
        @functools.wraps(func)  # Сохраняем метаданные
        def wrapper(*args, **kwargs):
            try:
                # Логика с параметрами
                return func(*args, **kwargs)
            except Exception as e:
                # Логируем, но не скрываем ошибку
                print(f"Ошибка в {func.__name__}: {e}")
                raise
        return wrapper
    return decorator
```

### ❌ Неправильно
```python
def bad_decorator(func):
    def wrapper(*args, **kwargs):  # Нет functools.wraps
        try:
            return func(*args, **kwargs)
        except Exception as e:
            print(f"Ошибка: {e}")
            # Исключение потеряно!
    return wrapper
```

## Частые ошибки

1. **Забывают `functools.wraps`** - теряются метаданные функции
2. **Скрывают исключения** - не перебрасывают ошибки
3. **Неправильная передача аргументов** - не используют `**kwargs`
4. **Проблемы с замыканиями** - неправильный захват переменных

## Применение в реальных проектах

### Логирование
```python
@log_function_call()
def api_call():
    # API запрос
    pass
```

### Кэширование
```python
@cache_with_ttl(ttl_seconds=300)
def expensive_calculation():
    # Дорогостоящее вычисление
    pass
```

### Валидация
```python
@validate_input(is_positive, "Число должно быть положительным")
def process_data(value):
    # Обработка данных
    pass
```

### Обработка ошибок
```python
@retry(max_attempts=3, delay=1.0)
def network_request():
    # Сетевой запрос
    pass
```

## Преимущества декораторов с параметрами

1. **Гибкость** - настраиваемое поведение
2. **Переиспользование** - один декоратор для разных случаев
3. **Читаемость** - явные параметры в коде
4. **Тестируемость** - легко тестировать с разными параметрами
5. **DRY принцип** - не дублируем код

## Заключение

Декораторы с параметрами - мощный инструмент для создания гибкого и переиспользуемого кода. Ключевые моменты:

- **Всегда используйте `functools.wraps`**
- **Правильно обрабатывайте исключения**
- **Используйте типизацию**
- **Тестируйте декораторы отдельно**
- **Документируйте параметры**

Декораторы позволяют элегантно добавлять функциональность без изменения исходного кода, что делает их незаменимым инструментом в арсенале Python-разработчика. 