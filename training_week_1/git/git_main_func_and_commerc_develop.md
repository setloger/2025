
## **Повторение основ Git**

**Базовые команды и концепции**

Git работает с тремя основными областями:

- **Working Directory** - ваша рабочая папка с файлами проекта
- **Staging Area (Index)** - промежуточная область для подготовки коммитов
- **Repository** - база данных с историей всех изменений

Основные команды:

- `git init` - создает новый Git-репозиторий в текущей папке
- `git clone <url>` - копирует удаленный репозиторий на локальную машину
- `git add <file>` - добавляет файл в staging area
- `git add .` - добавляет все измененные файлы
- `git commit -m "message"` - создает коммит с сообщением
- `git status` - показывает состояние файлов (modified, staged, untracked)
- `git branch` - показывает список веток
- `git branch <name>` - создает новую ветку
- `git checkout <branch>` - переключается на ветку
- `git merge <branch>` - объединяет ветку с текущей
- `git pull` - загружает изменения из удаленного репозитория
- `git push` - отправляет изменения в удаленный репозиторий

**Рабочий процесс Git**

Стандартный workflow выглядит так:

1. Редактируете файлы в Working Directory
2. `git add` перемещает изменения в Staging Area
3. `git commit` сохраняет snapshot в Repository
4. `git push` отправляет коммиты на удаленный сервер

Лучшие практики:

- Делайте частые коммиты с атомарными изменениями
- Пишите понятные сообщения коммитов в формате: "Тип: краткое описание"
- Регулярно проверяйте `git status` перед коммитами
- Используйте `git add <file>` вместо `git add .` для точного контроля


## **Стратегии ветвления для коммерческой разработки**

**GitFlow**

GitFlow включает пять типов веток:

**Master/Main ветка:**

- Содержит только стабильный, готовый к продакшену код
- Каждый коммит соответствует новому релизу
- Защищена от прямых коммитов

**Develop ветка:**

- Основная ветка разработки
- Содержит последние завершенные функции
- Исходная точка для feature веток

**Feature ветки:**

- Создаются от develop для новых функций
- Именование: `feature/feature-name`
- Сливаются обратно в develop через pull request

**Release ветки:**

- Создаются от develop для подготовки релиза
- Именование: `release/version-number`
- Позволяют исправлять баги без добавления новых функций
- Сливаются в master и develop

**Hotfix ветки:**

- Создаются от master для критических исправлений
- Именование: `hotfix/issue-description`
- Сливаются в master и develop

Команды GitFlow:

```bash
git flow init
git flow feature start new-feature
git flow feature finish new-feature
git flow release start 1.0.0
git flow release finish 1.0.0
git flow hotfix start critical-bug
git flow hotfix finish critical-bug
```

**GitHub Flow**

Упрощенная стратегия для быстрой разработки:

1. Создайте ветку от main
2. Добавьте коммиты
3. Откройте pull request
4. Обсудите и проведите ревью
5. Слейте в main
6. Удалите ветку

Преимущества: простота, подходит для непрерывной интеграции, быстрые циклы релизов.

## **Продвинутые техники Git**

**Управление историей коммитов**

**Git Rebase:**

```bash
git rebase main  # применяет коммиты текущей ветки поверх main
git rebase -i HEAD~3  # интерактивный rebase последних 3 коммитов
```

Интерактивный rebase позволяет:

- `pick` - оставить коммит как есть
- `reword` - изменить сообщение коммита
- `edit` - остановиться для редактирования
- `squash` - объединить с предыдущим коммитом
- `drop` - удалить коммит

**Git Squash:**

```bash
git reset --soft HEAD~3  # объединяет последние 3 коммита
git commit -m "Combined commit message"
```

**Работа с ошибками и откат изменений**

**Git Reset:**

- `git reset --soft HEAD~1` - отменяет коммит, оставляет изменения в staging
- `git reset --mixed HEAD~1` - отменяет коммит и staging (по умолчанию)
- `git reset --hard HEAD~1` - полностью удаляет изменения

**Git Checkout:**

- `git checkout <commit>` - переходит к определенному коммиту
- `git checkout <file>` - восстанавливает файл из последнего коммита

**Git Revert:**

- `git revert <commit>` - создает новый коммит, отменяющий изменения

**Git Bisect:**

```bash
git bisect start
git bisect bad  # текущий коммит содержит баг
git bisect good <commit>  # этот коммит работал
# Git автоматически найдет проблемный коммит
git bisect reset
```

**Временное сохранение изменений**

**Git Stash:**

```bash
git stash  # сохраняет текущие изменения
git stash pop  # восстанавливает последний stash
git stash list  # показывает все stash'и
git stash apply stash@{1}  # применяет конкретный stash
git stash drop stash@{1}  # удаляет stash
git stash clear  # удаляет все stash'и
```


## **Коммерческие аспекты использования Git**

**Приватные репозитории**

Преимущества GitHub для бизнеса:

- Профессиональная поддержка и SLA
- Интеграция с CI/CD системами
- Продвинутые инструменты безопасности
- Управление правами доступа на уровне организации
- GitHub Actions для автоматизации

Настройка организации:

- Создание команд с разными уровнями доступа
- Настройка branch protection rules
- Обязательные проверки перед merge
- Требование code review

**Безопасность и доступ**

Уровни доступа в GitHub:

- **Read** - просмотр кода и issues
- **Triage** - управление issues и pull requests
- **Write** - push в репозиторий
- **Maintain** - управление настройками репозитория
- **Admin** - полный доступ

Настройки безопасности:

- Двухфакторная аутентификация (2FA)
- SSH ключи для безопасного доступа
- Personal Access Tokens для API
- Signed commits для верификации авторства


## **Продвинутое логирование и анализ**

**Расширенный git log**

Полезные опции git log:

```bash
git log --oneline  # краткий формат
git log --graph  # показывает граф веток
git log --author="Name"  # фильтр по автору
git log --since="2 weeks ago"  # фильтр по дате
git log --grep="bug"  # поиск по сообщениям
git log -p  # показывает изменения в каждом коммите
git log --stat  # статистика изменений
git log --pretty=format:"%h %an %ar %s"  # кастомный формат
```

Анализ изменений:

```bash
git shortlog -sn  # статистика коммитов по авторам
git log --follow <file>  # история конкретного файла
git blame <file>  # кто изменил каждую строку
```

**Git hooks**

Типы hooks:

- **pre-commit** - выполняется перед коммитом
- **commit-msg** - проверяет сообщение коммита
- **pre-push** - выполняется перед push
- **post-receive** - выполняется на сервере после получения push

Пример pre-commit hook:

```bash
#!/bin/sh
# Запуск линтера перед коммитом
npm run lint
if [ $? -ne 0 ]; then
  echo "Linting failed. Commit aborted."
  exit 1
fi
```


## **Совместная работа и код-ревью**

**Pull Requests**

Структура хорошего PR:

- Описательное название
- Детальное описание изменений
- Ссылки на связанные issues
- Скриншоты для UI изменений
- Чек-лист для ревьюера

Процесс ревью:

1. Проверка соответствия требованиям
2. Анализ архитектурных решений
3. Проверка качества кода
4. Тестирование функциональности
5. Обратная связь и предложения

**Управление удаленными репозиториями**

Работа с upstream:

```bash
git remote add upstream <original-repo-url>
git fetch upstream
git checkout main
git merge upstream/main
git push origin main
```

Синхронизация форка:

```bash
git fetch upstream
git rebase upstream/main
git push --force-with-lease origin main
```


## **Лучшие практики для команды**

**Управление конфликтами**

Стратегии предотвращения конфликтов:

- Частые pull/rebase с основной веткой
- Разделение работы по разным файлам/модулям
- Короткие жизненные циклы веток
- Регулярная коммуникация в команде

Разрешение конфликтов:

```bash
git status  # показывает конфликтующие файлы
# Редактируем файлы, убираем маркеры конфликтов
git add <resolved-files>
git rebase --continue  # или git merge --continue
```

**Коммуникация в команде**

Правила командной работы:

- Уведомляйте команду о force push
- Создавайте резервные ветки перед сложными операциями
- Используйте понятные имена веток
- Документируйте нестандартные решения
- Проводите регулярные ретроспективы по Git workflow

Этот отчет покрывает все основные аспекты работы с Git в коммерческой разработке, от базовых концепций до продвинутых техник командной работы.

